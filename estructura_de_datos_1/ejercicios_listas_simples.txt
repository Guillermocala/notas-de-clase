	EJERCICIOS LISTAS SIMPLES
1- Dada una lista, formar la lista resultante de eliminar el nodo que sigue al nodo apuntado por p.
2- Dada una lista, devuelve el numero de elementos de la lista.
3- Destruye la lista retornando toda la memoria ocupada.
4- Haga un algoritmo que cree la lista organizada ascendentemente.
5- Implemente una funcion que dada una lista enlazada ptr, devuelva otra lista ptr1 con solamente
los nodos que almacenan un dato mayor que el promedio.
6-Hacer una funcion que retorna la posicion de la aparicion media del valor ELEM, la cual existe que
existen tantas ocurrencias del elemento antes que el(incluyendolo, si hay un numero par de apariciones)
que despues de el. por ej, para la lista de valores enteros <1,4,2,5,2,6,2,1,6,2,6>, la posicion
de la aparicion media del valor 2 es 5, la posicion de la aparicion media del valor 6 es 9, y
la del valor 5 es 4. si no ocurre retorna 0.
7- Hacer una funcion que deje en lista una sola ocurrencia de cada uno de los elementos presentes. garantizando que
sea la aparicion media del elemento la que permaneza. por ej, despues de podar la lista de valores enteros <1,4,2,5,2,6,2,1,6,2,6>
se obtiene la lista <1,4,5,2,6>
8- Hacer una funcion que retorne la posicion de la i-esima ocurrencia del elem de la lista. Si hay menos de
i ocurrencias, retorna el valor de 0.
9- Hacer una funcion que deje en lista todos los elementos de lista menores que elem, y en lista2 los mayores a dicho
elemento. Suponga que las listas list1 y list2 llegan inicializadas y vacias a la rutina.
10- La mediana de una lista se define como el elemento de dicha secuencia tal que la mitad de los elementos son menores
que el y la otra mitad mayores o iguales. suponiendo que la lista list no es vacia, no ordenada y sin elementos repetidos, esta
funcion calcula su mediana.
11- Hacer una funcion que retorna la lista de ceros y unos correspondientes a la representacion binaria del entero positivo num.
Por ej, si num = 215, binario = <11010111>.
12- Hacer unafuncion que diga si una lista de caracteres es palindroma(igual leerla de izq a der que de der a izq). por ej,
son palindromo <ANITALAVALATINA> esta funcion indica si la lista list es palindromo.
13- Hacer una funcion que diga si la lista list1 y list2 son semejantes: son semejantes si tienen la misma info en diferente orden.
14- Hacer una funcion que diga que retorna el elemento de la lista list cuyo valor es maximo, suponiendo la existencia
de una relacion de orden < definida entre los elementos de la lista. La lista list no es vacia.
15- Hacer una funcion que diga si todos los elementos de la lista aparecen igual numero de veces.
16- Hacer una funcion que informe si la lista list1 es mayor que la lista list2, utilizando el sgte criterio para decidir
si una lista es mayor que otra: Sea list1 = <a1, a2, ..., an> y list2 = <b1, b2, ..., bm> se dice que list1 es mayor que list2
si: 1. ((ai=b) 1 <= i <= m) y (n > m)
	 2. ej <= n, j <= m (ai = bi 1 <= i <= j)  y (aj >bj)
17- Hacer una funcion que diga si la lista 2 esta contenida en la lista 1.
18- Inserta la list2 en la list1 de manera que el primer elemento de list2 quede en la posicion de la list1.
19- Hacer una funcion que elimine de la lista todos los elementos correspondientes entre la posicion p1 y la posicion p2 inclusive.
20- Elimina todas las ocurrencias de la list2 en la list1.
21- Hacer un procedimiento que ordene ascendentemente la lista ya creada.
22- list es una lista de digitos. intLista es el entero que se puede crear a partir de esa lista. por ej, si list = <4,2,1,4>, intLista = 4214.
23- Elimina de la lista list1 todos los elementos que aparecen en la lista list2.
24- Void sumarLista(lista list1, lista list2)
	list1 y list2 son listas de digitos que representan un numero entero. Esta rutina suma list1 y list2. por ej, si
	list1 = <4,2,1,4> y list2 = <3,4>, despues de la llamada a la funcion el valor de list1 es <4,2,4,8>.
25- Void restarLista(lista list1, lista list2)
	list1 y list2 son listas de digitos que representan un numero entero. Esta rutina suma list1 y list2. por ej, si
	list1 = <4,2,1,4> y list2 = <3,4>, despues de la llamada a la funcion el valor de list1 es <4,1,8,0>.

DESARROLLO======================================================================
1-------------------------------------------------------------------------------
-----en el main:
case 6:
	system("cls");
	cout << "Ingrese el dato a buscar: ";
	cin >> i;
	ptr = ElimSgte(ptr, i);
	break;
-----en la funcion:
nodoa *ElimSgte(nodoa *ptr, int elem)
{
   nodoa *p, *q;
   p = Buscarllave(ptr, elem);
   if(p == NULL || p->sig == NULL)
   {
      cout << "No se puede eliminar" << endl;
   }
   else
   {
      q = p->sig;
      p->sig = q->sig;
      free(q);
   }
   return ptr;
}
2-------------------------------------------------------------------------------
-----en el main:
case 6:
	system("cls");
	Cuenta(ptr);
	getch();
	break;
-----en la funcion:
/*se puede añadir dentro de la funcion mostrar solamente colocando un contador*/
void *Cuenta(nodoa *ptr)
{
   int cant = 0;
   nodoa *p;
   p = ptr;
   while(p != NULL)
   {
      p = p->sig;
      cant++;
   }
   cout << "La cantidad de elementos de la lista es: " << cant << endl;
}
3-------------------------------------------------------------------------------
-----en el main:
case 6:
	system("cls");
	Memory(ptr);
	ptr = DestroyList(ptr);
	getch();
	break;
-----en la funcion:
void *Memory(nodoa *ptr)
{
   int cant = 0;
   nodoa *p, *q;
   p = ptr;
   while(p != NULL)
   {
      cant += sizeof(p);
      p = p->sig;
   }
   cout << "La cantidad de memoria de la lista es: " << cant << " bytes" << endl;
}
nodoa *DestroyList(nodoa *ptr)
{
   nodoa *p, *r;
   r = ptr;
   while(r != NULL)
   {
      p = ptr;
      if(p->sig == NULL)
      {
         ptr = NULL;
         free(p);
         cout << "Lista destruida" << endl;
         return ptr;
      }
      else
      {
         ptr = ptr->sig;
         free(p);
      }
      r = r->sig;
   }
}
4-------------------------------------------------------------------------------
-----en el main:
case 6:
	system("cls");
	if(ptr == NULL || ptr->sig == NULL)
	{
		printf("La lista esta vacia o tiene un solo elemento");
	}
	else
	{
		ptr = OrdenarAsc(ptr);
	}
	getch();
	break;
-----en la funcion:
nodoa *OrdenarAsc(nodoa *ptr)
{
   nodoa *p, *q, *aux, *aux2;
   p = ptr;
   while(p != NULL)
   {
      q = ptr;
      while(q != NULL)
      {
         if(q->sig != NULL && q->info > q->sig->info)
         {
            aux = q->sig;
            if(q == ptr)
            {
               q->sig = aux->sig;
               aux->sig = q;
               ptr = aux;
            }
            else
            {
               aux2 = ptr;
               while(aux2->sig != q)
               {
                  aux2 = aux2->sig;
               }
               q->sig = aux->sig;
               aux2->sig = aux;
               aux->sig = q;
            }
				/*si movemos el nodo que contiene a p, debemos devolverlo a su posicion
				anterior para no alterar el buen funcionamiento del algoritmo*/
            if(q == p)
            {
               p = aux;
            }
         }
         q = q->sig;
      }
      p = p->sig;
   }
   cout << "lista ordenada" << endl;
   return ptr;
}
5-------------------------------------------------------------------------------
-----en el main:
case 6:
	system("cls");
	if(ptr == NULL || ptr->sig == NULL)
	{
		printf("La lista esta vacia o tiene un solo elemento");
	}
	else
	{
		ptr1 = MayorPromedio(ptr, ptr1);
		Mostrar(ptr);
		Mostrar(ptr1);
	}
	getch();
	break;
-----en la funcion:
nodoa *MayorPromedio(nodoa *ptr, nodoa* ptr1)
{
   int prom, cant = 0, cont = 0;
   nodoa *q;
   q = ptr;
   while(q != NULL)
   {
      cant += q->info;
      cont++;
      q = q->sig;
   }
   prom = cant / cont;
   cout << "El promedio es: " << prom << endl;
   getch();
   q = ptr;
   while(q != NULL)
   {
      if(q->info >= prom)
      {
         ptr1 = InsertaCabeza(ptr1, q->info);
      }
      q = q->sig;
   }
   return ptr1;
}
6-------------------------------------------------------------------------------
-----en el main:
case 6:
	system("cls");
	if(ptr == NULL || ptr->sig == NULL)
	{
		printf("La lista esta vacia o tiene un solo elemento");
	}
	else
	{
		cout << "Ingrese el dato a buscar: ";
		cin >> i;
		j = PosMedia(ptr, i);
		if(j != 0)
		{
			cout << "La posicion media del dato " << i << " es: " << j << endl;
		}
		else
		{
			cout << "No se puede operar..." << endl;
		}
	}
	getch();
	break;
-----en la funcion:
int PosMedia(nodoa *ptr, int elem)
{
   int pos = 1, cant = 0, exit = 0;
   nodoa *p, *q;
   p = Buscarllave(ptr, elem);
   if(p == NULL)
   {
      cout << "Elemento no encontrado" << endl;
      return exit;
   }
   else
   {
      /*recorremos la lista para ver cuantas ocurrencias del elem hay*/
      for(p = ptr; p != NULL; p = p->sig)
      {
         if(p->info == elem)
         {
            cant++;
         }
      }
      if(cant != 1)
      {
         /*si es impar reasignamos el valor con su equivalencia al valor medio, el cual
         seria la mitad + 1. de lo contrario, solo la mitad*/
         if(cant % 2 != 0)
         {
            cant = ((cant / 2) + 1);
         }
         else
         {
            cant = (cant / 2);
         }
         /*recorremos y llegamos hasta el elemento y retornamos su posicion*/
         for(p = ptr; p != NULL; p = p->sig)
         {
            if(p->info == elem)
            {
               cant--;
               if(cant == 0)
               {
                  return pos;
               }
            }
            pos++;
         }
      }
      else
      {
         /*si solo hay una ocurrencia del elem retornamos su posicion ya que seria
         su posicion media*/
         for(q = ptr; q != NULL; q = q->sig)
         {
            if(q->info == elem)
            {
               break;
            }
            pos++;
         }
         return pos;
      }
   }
}
7-------------------------------------------------------------------------------
-----en el main:
case 6:
	system("cls");
	if(ptr == NULL || ptr->sig == NULL)
	{
		printf("La lista esta vacia o tiene un solo elemento");
	}
	else
	{
		ptr1 = InsertaPos(ptr, ptr1);
		Mostrar(ptr);
		Mostrar(ptr1);
	}
	getch();
	break;
-----en la funcion:
/*usamos PosMedia la cual creamos en el ejercicio pasado, asi que no la pondre de nuevo*/
nodoa *InsertaPos(nodoa *ptr, nodoa *ptr1)
{
   int pos, cant = 1;
   nodoa *p, *q;
   /*recorremos la lista para saber cuantos elementos hay en total*/
   for(p = ptr; p != NULL; p = p->sig)
   {
      cant++;
   }
   /*empezamos en 1(la posicion inicial de la lista) y terminamos en el max de la lista*/
   for(int i = 1; i <= cant; i++)
   {
      /*recorremos la lista para hallar la posicion i*/
      for(p = ptr; p != NULL; p = p->sig)
      {
         pos = PosMedia(ptr, p->info);
         if(pos == i)
         {
            /*verificamos que el elemento no este repetido, porque no nos interesa
            guardar mas de una ocurrencia*/
            q = Buscarllave(ptr1, p->info);
            if(q == NULL)
            {
               ptr1 = InsertaCola(ptr1, p->info);
            }
         }
      }
   }
   return ptr1;
}
8-------------------------------------------------------------------------------
-----en el main:
case 6:
	system("cls");
	if(ptr == NULL || ptr->sig == NULL)
	{
		printf("La lista esta vacia o un elemento");
	}
	else
	{
		cout << "Ingrese el dato a buscar: ";
		cin >> i;
		j = PosOcurrencia(ptr, i);
		if(j > 0)
		{
			cout << "La posicion es: " << j << endl;
		}
		else
		{
			cout << "El numero pedido de ocurrencia no corresponde al de las almacenadas" << endl;
		}
	}
	getch();
	break;
-----en la funcion:
int PosOcurrencia(nodoa *ptr, int elem)
{
   int cant = 0, ocu, pos = 1;
   nodoa *q;
   q = Buscarllave(ptr, elem);
   if(q == NULL)
   {
      cout << "Elemento no encontrado..." << endl;
      /*para no añadir mas casos o usar declaraciones aparte uso una variable
      ya inicializada para salir*/
      return cant;
   }
   else
   {
      for(q = ptr; q != NULL; q = q->sig)
      {
         if(q->info == elem)
         {
            cant++;
         }
      }
      cout << "El dato " << elem << " tiene " << cant << " ocurrencias" << endl;
      cout << "Ingrese la ocurrencia de la cual desea saber su posicion: ";
      cin >> ocu;
      if(ocu > 0 && ocu < cant)
      {
         for(q = ptr; q != NULL; q = q->sig)
         {
            if(q->info == elem)
            {
               ocu--;
               if(ocu == 0)
               {
                  return pos;
               }
            }
            pos++;
         }
      }
      else
      {
         pos = 0;
         return pos;
      }
   }
}
9-------------------------------------------------------------------------------
-----en el main:
case 6:
	system("cls");
	if(ptr == NULL || ptr1 == NULL)
	{
		printf("Lista 1 o lista 2 vacia");
	}
	else
	{
		cout << "Ingrese el dato: ";
		cin >> i;
		MenorMayorElem(ptr, ptr1, i);
	}
	getch();
	break;
-----en la funcion:
void MenorMayorElem(nodoa *&ptr, nodoa *&ptr1, int elem)
{
   nodoa *p;
   for(p = ptr; p != NULL; p = p->sig)
   {
      if(p->info <= elem)
      {
         ptr = Eliminacion(ptr, p->info);
         p = ptr;
      }
   }
   for(p = ptr1; p != NULL; p = p->sig)
   {
      if(p->info >= elem)
      {
         ptr1 = Eliminacion(ptr1, p->info);
         p = ptr1;
      }
   }
   cout << "Operacion realizada exitosamente" << endl;
}
10------------------------------------------------------------------------------
-----en el main:

-----en la funcion:
11------------------------------------------------------------------------------
-----en el main:

-----en la funcion:
12------------------------------------------------------------------------------
-----en el main:

-----en la funcion:
13------------------------------------------------------------------------------
-----en el main:

-----en la funcion:
14------------------------------------------------------------------------------
-----en el main:

-----en la funcion:
15------------------------------------------------------------------------------
-----en el main:

-----en la funcion:
16------------------------------------------------------------------------------
-----en el main:

-----en la funcion:
17------------------------------------------------------------------------------
-----en el main:

-----en la funcion:
18------------------------------------------------------------------------------
-----en el main:

-----en la funcion:
19------------------------------------------------------------------------------
-----en el main:

-----en la funcion:
20------------------------------------------------------------------------------
-----en el main:

-----en la funcion:
21------------------------------------------------------------------------------
-----en el main:

-----en la funcion:
22------------------------------------------------------------------------------
-----en el main:

-----en la funcion:
23------------------------------------------------------------------------------
-----en el main:

-----en la funcion:
24------------------------------------------------------------------------------
-----en el main:

-----en la funcion:
25------------------------------------------------------------------------------
-----en el main:

-----en la funcion:
FINAL===========================================================================
