EJERCICIOS DE PILAS DEL MODULO DE ESTRUCTURA DE DATOS

1- Dada una pila con elem repetidos hacer un algoritmo que busque un elem en la pila y elimine todas sus ocurrencias.
2- Dada una pila hacer un algoritmo que halle la sumatoria de sus elem y el promedio sin perder los datos de la pila original.
3- Dada una pila diga si la pila es palindroma.
4- Dada una pila hacer un algoritmo que intercambie el primer elem con el ultimo(tope) sin cambiar el resto de sus elementos.
5- Escriba un algoritmo para determinar si una cadena de caracteres de ingreso esta en la forma X C Y:
   en donde X es una cadena que consta de las letras "A" y "B" y donde Y es el inverson de X (es decir, si X="ABABBA" entonces
   Y="ABBABA") asuma que la cadena solo tiene letras y que se encuentran en una pila.
6- Escriba un algoritmo que muestre si el contenido de una pila tiene los parentesis apareados de la forma (((A))) .
7- Dada una pila hacer un algoritmo que elimine los elem repetidos de la pila dejando una sola ocurrencia.
8- Dada dos pilas tope1 y tope2 diga si son iguales.
9- Realice una funcion Reemplazar que contenga una pila y dos elem NUEVO y VIEJO de tal forma que si el segundo valor (VIEJO)
   aparece en algun lugar de la pila sea reemplazado por el primero (NUEVO) y diga cuantas veces realiza esta operacion.
10- Dada una pila hacer un algoritmo que elimine todos los elem mayores a un elemento elem dado.
11- Realice la implementacion de las operaciones basicas de las pilas usando vectores.
12- Realice la implementacion de las operaciones basicas de las pilas usando listas simples.
13- Dado un entero cree una pila con su representacion en binario.

DESARROLLO======================================================================

1-------------------------------------------------------------------------------
-----en el main:
case 7:
   system("clear");
   if(!PilaVacia(Tope))
   {
      Tope = ElimRep(Tope);
   }
   else
   {
      cout << "Lista vacia" << endl;
      cin.ignore();
      cin.get();
   }
   break;
-----en la funcion:
lista *ElimRep(lista *tope, int elem)
{
	lista *tope2;
	tope2 = InicPila(tope2);
	while(!PilaVacia(tope))
	{
		if(InfoPila(tope) != elem)
		{
			tope2 = InsertaPila(tope2, InfoPila(tope));
		}
		tope = ElimPila(tope);
	}
	while(!PilaVacia(tope2))
	{
		tope = InsertaPila(tope, InfoPila(tope2));
		tope2 = ElimPila(tope2);
	}
	return tope;
}
2-------------------------------------------------------------------------------
-----en el main:
case 7:
   system("clear");
   if(!PilaVacia(Tope))
   {
      SumyProm(Tope);
   }
   else
   {
      cout << "Lista vacia" << endl;
      cin.ignore();
      cin.get();
   }
   break;
-----en la funcion:
void SumyProm(lista *tope)
{
	lista *tope2;
	tope2 = InicPila(tope2);
	int prom, c, sum;
	c = 0;
	sum = 0;
	while(!PilaVacia(tope))
	{
		c++;
		sum += InfoPila(tope);
		tope2 = InsertaPila(tope2, InfoPila(tope));
		tope = ElimPila(tope);
	}
	prom = sum / c;
	cout << "El promedio es: " << prom << endl;
	cout << "La sumatoria de los elementos es: " << sum << endl;
	while(!PilaVacia(tope2))
	{
		tope = InsertaPila(tope, InfoPila(tope2));
		tope2 = ElimPila(tope2);
	}
	cin.ignore();
	cin.get();
}
3-------------------------------------------------------------------------------
-----en el main:
case 7:
   system("clear");
   if(!PilaVacia(Tope))
   {
      Tope = Palindrome(Tope);
   }
   else
   {
      cout << "Lista vacia" << endl;
      cin.ignore();
      cin.get();
   }
   break;
-----en la funcion:
lista *Palindrome(lista *tope)
{
	lista *tope2, *tope3, *tope4;
	tope2 = InicPila(tope2);
	tope3 = InicPila(tope3);
	tope4 = InicPila(tope4);
	while(!PilaVacia(tope))
	{
		tope2 = InsertaPila(tope2, InfoPila(tope));
		tope3 = InsertaPila(tope3, InfoPila(tope));
		tope = ElimPila(tope);
	}
	while(!PilaVacia(tope3))
	{
		tope = InsertaPila(tope, InfoPila(tope3));
		tope4 = InsertaPila(tope4, InfoPila(tope3));
		tope3 = ElimPila(tope3);
	}
	while(!PilaVacia(tope2))
	{
		if(InfoPila(tope2) == InfoPila(tope4))
		{
			tope4 =  ElimPila(tope4);
		}
		tope2 = ElimPila(tope2);
	}
	if(!PilaVacia(tope4))
	{
		cout << "La pila NO es palindroma" << endl;
	}
	else
	{
		cout << "La pila es palindroma" << endl;
	}
	cin.ignore();
	cin.get();
	return tope;
}
4-------------------------------------------------------------------------------
-----en el main:
case 7:
   system("clear");
   if(!PilaVacia(Tope))
   {
      Intercambio(Tope);
   }
   else
   {
      cout << "Lista vacia" << endl;
      cin.ignore();
      cin.get();
   }
   break;
-----en la funcion:
void Intercambio(lista *tope)
{
	int first, last;
	lista *topeAux;
	topeAux = InicPila(topeAux);
	first = InfoPila(tope);
	tope = ElimPila(tope);
	while(!PilaVacia(tope))
	{
		topeAux = InsertaPila(topeAux, InfoPila(tope));
		tope = ElimPila(tope);
	}
	last = InfoPila(topeAux);
	topeAux = ElimPila(topeAux);
	tope = InsertaPila(tope, first);
	while(!PilaVacia(topeAux))
	{
		tope = InsertaPila(tope, InfoPila(topeAux));
		topeAux = ElimPila(topeAux);
	}
	tope = InsertaPila(tope, last);
}
5-------------------------------------------------------------------------------
hay que modificar la maqueta para insertar cadenas
-----en el main:
case 7:
   system("clear");
   if(!PilaVacia(Tope))
   {
      if(PalindString(InfoPila(Tope)))
      {
         cout << "es palindrome" << endl;
         cin.ignore();
         cin.get();
      }
      else
      {
         cout << "no es palindrome" << endl;
         cin.ignore();
         cin.get();
      }
   }
   else
   {
      cout << "Lista vacia" << endl;
      cin.ignore();
      cin.get();
   }
   break;
-----en la funcion:
bool PalindString(string info)
{
	char list1[50], list2[50];
	int limit;
	strcpy(list1, info.c_str());
	strcpy(list2, info.c_str());
	strrev(list2);
	limit = strlen(list1);
	cout << "Cadena normal: " << list1 << endl;
	cout << "Cadena inversa: " << list2 << endl;
	for(int i = 0; i < limit; i++)
	{
		if(list1[i] != list2[i])
		{
			return false;
		}
	}
	return true;
}
6-------------------------------------------------------------------------------
Este algoritmo NO conserva la pila original
-----en el main:
case 7:
   system("clear");
   if(!PilaVacia(Tope))
   {
      if(Parentesis(Tope))
      {
         cout << "Parentesis apareados correctamente" << endl;
      }
      else
      {
         cout << "Parentesis no apareados correctamente" << endl;
      }
      cin.ignore();
      cin.get();
   }
   else
   {
      cout << "Lista vacia" << endl;
      cin.ignore();
      cin.get();
   }
   break;
-----en la funcion:
bool Parentesis(lista *tope)
{
	lista *tope2, *tope3, *tope4;
	tope2 = InicPila(tope2);
	tope3 = InicPila(tope3);
	tope4 = InicPila(tope4);
	char dato;
	while(!PilaVacia(tope))
	{
		dato = InfoPila(tope);
      /*si evaluamos con != no funciona y pasa todo a tope3*/
		if(dato == '(' || dato == ')')
		{
			tope3 = InsertaPila(tope3, InfoPila(tope));
		}
		else
		{
			tope2 = InsertaPila(tope2, InfoPila(tope));
		}
		tope = ElimPila(tope);
	}
   /*si no hay parentesis*/
	if(PilaVacia(tope3))
	{
		return false;
	}
	else
	{
		while(!PilaVacia(tope3))
		{
			dato = InfoPila(tope3);
         /*como quedan en orden inverso preguntamos por el contrario*/
			if(dato == ')')
			{
				tope4 = InsertaPila(tope4, dato);
			}
			else
			{
				if(PilaVacia(tope4))
				{
					return false;
				}
				else
				{
					tope4 = ElimPila(tope4);
				}
			}
			tope3 = ElimPila(tope3);
		}
		if(!PilaVacia(tope4))
		{
			return false;
		}
		return true;
	}
}
7-------------------------------------------------------------------------------
-----en el main:
case 7:
   system("clear");
   if(!PilaVacia(Tope))
   {
      Tope = UnicaOcu(Tope);
   }
   else
   {
      cout << "Lista vacia" << endl;
      cin.ignore();
      cin.get();
   }
   break;
-----en la funcion:
lista *UnicaOcu(lista *tope)
{
	int dato;
	lista *tope2, *tope3;
	tope2 = InicPila(tope2);
	tope3 = InicPila(tope3);
	while(!PilaVacia(tope))
	{

		dato = InfoPila(tope);
		tope = ElimPila(tope);
		while(!PilaVacia(tope))
		{
			if(InfoPila(tope) != dato)
			{
				tope2 = InsertaPila(tope2, InfoPila(tope));
			}
			tope = ElimPila(tope);
		}
		if(!PilaVacia(tope2))
		{
			while(!PilaVacia(tope2))
			{
				tope = InsertaPila(tope, InfoPila(tope2));
				tope2 = ElimPila(tope2);
			}
		}
		tope3 = InsertaPila(tope3, dato);
	}
	while(!PilaVacia(tope3))
	{
		tope = InsertaPila(tope, InfoPila(tope3));
		tope3 = ElimPila(tope3);
	}
	return tope;
}
8-------------------------------------------------------------------------------
-----en el main:

-----en la funcion:
